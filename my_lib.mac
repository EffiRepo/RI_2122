ratprint:false$
algebraic:true$
/*Funzioni per semplificare espressioni complesse*/
mySimp(expr):=block(
[res],
ratprint:false,
res:factor(fullratsimp(expand(trigreduce(expand(ratsimp(expr)))))),
return(res)
)$
simp(expr):=block(
  [res],
  res:factor(expand(trigreduce(expand(expr)))),
  return(res)
)$
/*Determinare la dimensione di una matrice*/
size(M):=[length(M), length(transpose(M))]$
/*Prodotto Vettoriale*/
vect_prod(A,B):=block([E, M, AxB, res],
/*Verifica delle dimensioni dei vettori*/
if ((length(A) # length(B)) or (length(A) < 3)) then
   error("Inserisci due vettori lunghi uguali")
else(
   /*Definisco vettore simbolico per i versori*/  
   E:matrix([e[x]],[e[y]],[e[z]]),
   /*Definisco matrice per il prodotto vettoriale*/   
   M:addrow(transpose(E),transpose(A),transpose(B)),
   /*Calcolo il prodotto vettoriale. Letsimp necessario per 
   coprire anche i casi di vettori simbolici assunti come paralleli*/
   AxB:mySimp(determinant(M)),
   /*Verifico se i due vettori sono paralleli*/
   if AxB = 0 then
     res: true
   else 
     res: false),          
 return([AxB, res])
 )$
/*Verifica della proprietà di isometria*/
isRot(R):=block(
[RT, RRT, II, sz, det],
     /*Controllo se R è quadrata ed è una matrice*/
     sz: size(R),
     if sz[1]<1 or sz[1] # sz[2] then
       error("Inserire una matrice quadrata"),
     RT: transpose(R),
     RRT:mySimp(R.RT),
     II: identfor(R),
     det: mySimp(determinant(R)),
     if RRT = II and det = 1 then
     true
     else
     false
)$
/*Matrice di Rotazione nel Piano*/
rot2(alpha):=mySimp(matrix([cos(alpha), -sin(alpha)],[sin(alpha), cos(alpha)]))$
/*Matrice di Rotazione nello Spazio*/
rot3X(theta):=mySimp(matrix([1,0,0],[0,cos(theta),-sin(theta)],[0,sin(theta),cos(theta)]))$
rot3Y(theta):=mySimp(matrix([cos(theta),0,sin(theta)],[0,1,0],[-sin(theta),0,cos(theta)]))$
rot3Z(theta):=mySimp(matrix([cos(theta),-sin(theta),0],[sin(theta),cos(theta),0],[0,0,1]))$
/*Matrice di rotazione noto asse principale ed angolo*/
rot3(a, theta):=block(
[axis:[x,y,z], R],
/*Verifico che l'asse in input sia un asse principale*/
if not(member(a, axis)) then
  error("Inserisci un asse valido")
/*Verifico che l'angolo in input sia un simbolo o scalare*/
elseif nonscalarp(theta) and not(symbolp(theta))
       and not(subvarp(theta)) then
       error("Inserisci un angolo scalare o simbolico")
       else(
/*Ritorna la matrice di rotazione corrispondente*/
         if(a = x) then return(rot3X(theta)),
         if(a = y) then return(rot3Y(theta)),
         if(a = z) then return(rot3Z(theta))        
)
)$

/*Calcolo di autovalori e autovettori*/
myColspace(A):= block([m, nc, nr, cs : set(), pos, x, algebraic : true, c_min],
require_unblockedmatrix(A, "first","myColspace"),
[nr, nc] : matrix_size(A),
if nc = 0 or nr = 0 then (
error("The argument to 'columnspace' must be a matrix with one or more rows and columns")),
 m : triangularize(A),
 c_min : 1,
 for i : 1 thru nr while c_min <= nc do (
if listp(pos : locate_matrix_entry(m, i, c_min, i, nc, lambda([x], x # 0), 'bool)) then (
c_min : second(pos) + 1,
cs : adjoin(col(A,second(pos)) ,cs))),
funmake('span, listify(cs))
)$
imagesimp(A):=block(
[M:A, bool:false, imm, i, j, sz:size(A),w:[]],
      algebraic:true,
      for i:1 thru sz[1] do(  
          w:append(w,[1]),
          bool:false,
             for j:1 thru sz[2] do(
               if M[j,i] # 0 and bool = false then(               
                 w[i]:M[j,i], bool:true              
               ),
             M[j,i]:ratsimp(M[j,i]/w[i])           
             )                   
      ),      
      imm:ratsimp(myColspace(M)),
      return([imm,w])
)$
kersimp(A):=block(
[M:A, bool:false, ker, i, j, w, sz:size(A)],
      algebraic:true,
      for i:1 thru sz[1] do(
        for j:1 thru sz[1] do(
          if M[i,j] # 0 then(
            w:M[i,j],
            M:M/w,
            bool:true,
            return([M,w])
          ),
          if bool then return([M,w]) 
        ),
        if bool then return([M,w]) 
      ),
      ker:nullspace(M),
      return([ker,w])
)$
myEigens(A):=block(
[II, sII, sIImA, pA, i, j, k, sz:size(A), specSz, adj, adji, imm, ker, v, M, wImm, wKer, zeros, bool],
     if (sz[1] # sz[2]) and (sz[1] <2) then 
       error("Matrice non quadrata o vettore in ingresso"),
/* definisco una matrice identità delle dimensioni di A*/
     II: identfor(A),
/*Calcolo il polinomio caratteristico di A*/
     sIImA: s*II-A,
     pA:expand(trigreduce(expand(determinant(sIImA)))),
/*Determino gli autovalori e controllo il loro numero*/
     eigs:solve(pA=0,s),
     specSz: length(eigs),
     adj:adjoint(sIImA),
     v:[], 
     zeros: zeromatrix(sz[1],sz[2]),
     for i:1 thru specSz do(
       adji: subst(eigs[i], adj),
/*Se l'aggiunta è nulla l'autovettore è preso come vettore nel nucleo di (sI-A)*/
       if adji = zeros then(
         [kerA,wKer]:kersimp(subst(eigs[i],sIImA)),
         for j:1 thru length(kerA) do(
/*Tramite args() prendiamo una colonna linearmente indipendente*/
           v:append(v,[args(kerA)[j]])
         )
     ) else (
         [immA,wImm]:imagesimp(adji),
/*Tramite args()[1] prendiamo una colonna linearmente indipendente*/
         v:append(v,[args(immA)[1]]))
     ),
     return([map(rhs,eigs),v,wImm,wKer])
)$
/*Generare una matrice di rotazione tramite angoli nautici*/
nautRot(axList, angleList):=block(
[axis:[x, y, z], R, isAxeList, i, newAngleList:ratsimp(angleList)],
/*Controllo che l'input sia una lista di 3 elementi*/
for i:1 thru 3 do(isAxeList:member(axList[i],axis)),
if length(axList) # 3 and not(nonscalarp(axList)) and not(isAxeList) then
  error("Inserisci come lista una permutazione di [x,y,z]")
/*Verifico che l'angolo in input sia un simbolo o scalare*/
elseif nonscalarp(theta) and not(symbolp(theta))
       and not(subvarp(theta)) then
       error("Inserisci un angolo scalare o simbolico")
else(
/*Calcolo della matrice di rotazione ed applichiamo semplificazioni*/
  R:rot3(axList[1], newAngleList[1]).
    rot3(axList[2],newAngleList[2]).rot3(axList[3], newAngleList[3]),
  return(R)
)
)$
/*Generare una matrice di rotazione tramite angoli di Eulero*/
euleroRot(axList, angle):=block(
[axis:[x, y, z], R, isAxeList, i, sgn:1], 
/*Controllo che l'input sia una lista di 3 elementi*/
for i:1 thru 3 do(isAxeList:member(axList[i],axis) and axList[1] = axList[3]),
if length(axList) # 3 and not(nonscalarp(axList)) and not(isAxeList) then
  error("Inserisci come lista una permutazione di [x,y,z] con il primo e il terzo parametro coincidente")
/*Verifico che l'angolo in input sia un simbolo o scalare*/
elseif nonscalarp(theta) and not(symbolp(theta))
       and not(subvarp(theta)) then
       error("Inserisci un angolo scalare o simbolico")
else(
/*Calcolo della matrice di rotazione*/
  /*x.y.-x-> z, -x.-y.x-> z*/
  if axList[1] = axis[1] and axList[2] = axis[2] then(
    R:rot3X(sgn*%pi/2).rot3Y(sgn*theta).rot3X(-sgn*%pi/2)
  ), 
  /*-x.z.x -> y, x.-z.-x -> y*/
  if axList[1] = axis[1] and axList[2] = axis[3] then(
    R:rot3X(-sgn*%pi/2).rot3Z(sgn*theta).rot3X(sgn*%pi/2)
  ),
  /*-y.x.y -> z, y.-x.-y -> z*/
  if axList[1] = axis[2] and axList[2] = axis[1] then(
    R:rot3Y(-sgn*%pi/2).rot3X(sgn*theta).rot3Y(sgn*%pi/2)
  ),    
  /*y.z.-y -> x, -y.-z.y -> x*/
  if axList[1] = axis[2] and axList[2] = axis[3] then(
    R:rot3Y(sgn*%pi/2).rot3Z(sgn*theta).rot3Y(-sgn*%pi/2)
  ),  
  /*z.x.-z -> y, -z.-x.z -> y*/
  if axList[1] = axis[3] and axList[2] = axis[1] then(
    R:rot3Z(sgn*%pi/2).rot3X(sgn*theta).rot3Z(-sgn*%pi/2)
  ),
  /*-z.y.z -> x, z.-y.-z -> x*/
  if axList[1] = axis[3] and axList[2] = axis[2] then(
    R:rot3Z(-sgn*%pi/2).rot3Y(sgn*theta).rot3Z(sgn*%pi/2)
  )
), return(R)
)$
/*Matrice antisimmetrica*/
S(v):=block(
[S],
/*Controlliamo che v sia un vettore o una lista*/
if not(nonscalarp(v)) or length(v) < 3 or listp(v) then
  error("Inserire un vettore colonna di tre elementi")
else(
  S:matrix([0,-v[3,1],v[2,1]],[v[3,1],0,-v[1,1]],[-v[2,1],v[1,1],0])
)
)$
/*calcolare esponenziale di matrice*/
expLaplace(A,t):=block(
[sz, II, s, sIImA, sIImAT, i, iltA], 
     /*Controlliamo che la matrice inserita sia quadrata*/
     sz:size(A),
     if(sz[1]#sz[2]) then error("Matrice non Quadrata"),
     II:ident(sz[1]),
     sIImA:invert(s*II-A),     
     iltA:zerofor(A),
     for i:1 thru sz[1] do(
       for j:1 thru sz[2] do(
         iltA[i,j]:ilt(sIImA[i,j],s,t)
       )
     ),
     return(iltA)
)$
expVect(A,t):=block(
[sz, V, eigVec, Vi, D, expD, res, theta],
      sz:size(A),
      if(sz[1]#sz[2]) then error("Matrix not Square"),
/*Definiamo una matrice vuota pronta a contenere vettori colonna di dimensione 3*/
      V:zeromatrix(sz[1],0),
      eigVec:myEigens(A)[2],
      for i:1 thru sz[1] do(
        V:addcol(V, eigVec[i])
      ),
      Vi:invert(V), 
      D:Vi.A.V,
      expD:D,
      for i:1 thru sz[1] do(
       expD[i,i]:exp(expD[i,i]*t)
      ),
      res:V.expD.Vi,
      return(mySimp(res))
)$
/*Norma di un vettore*/
normalize(v):=block(
[norm:0, u, i, sz, vv],
sz:size(v),
/*Mi assicuro che v sia un vettore colonna*/
if nonscalarp(v) and sz[2] = 1  then(
  vv:ratsimp(v),
  /*Applico una semplificazione numerica, dividendo il vettore per una sua componente non nulla, al fine di migliorare l'output*/
  for i:1 thru sz[1] do(
    if vv[i] # 0 then
       return(vv:vv/vv[i,1])
  ),
  norm:sqrt(transpose(vv).vv),
  u:vv/norm
),
return([norm,u]) 
)$
/*Rodrigues*/
rodrigues(v,theta):=block(
[S,II,S2,rodr,norm,u],
/*normaliziamo il vettore*/
[norm,u]:mySimp(normalize(v)),
/*calcoliamo l'antisimmetrica sul versore*/
 S:S(u),
 II:ident(size(v)[1]),
 S2:S.S,
 /*implementiamo la formula di rodrigues, moltiplicando l'angolo per la norma di v*/
 rodr:II+S2*(1-cos(norm*theta))+S*sin(norm*theta),
 return(trigsimp(rodr))
)$
/*data una matrice verificare che è antisimmetrica*/
isAsim(M):=block(
[sz:size(M), t, i, j, diagCheck, sideCheck, b],
/*Verifichiamo che la matrice inserita sia quadrata*/        
if sz[1]#sz[2] or sz[1] < 2 or sz[2] < 2 then error("Inserire una matrice quadrata"),
/*Per verificare che una qualsiasi matrice m x n quadrata sia antisimmetrica usiamo una tecnica ricorsiva.*/
/*caso base:*/
if sz[1] = 2 then(
/*Controllo che la diagonale sia tutta nulla*/
  diagCheck: M[1,1] = M[2,2] and M[1,1] = 0,
/*Controllo che gli elementi fuori diagonale
  siano uguali a meno del segno*/
  sideCheck: M[1,2] = -M[2,1],
/*Uniamo le due condizioni necessarie*/
  b: diagCheck and sideCheck,
  return(is(b))
) else (
/*caso generale*/
  j:1,
  diagCheck: M[j,j] = 0,
  for t:1 thru sz[1] do(
/*Calcolo i = t mod(n)*/
    i:remainder(t,sz[1]),
    if i = 0 then i:n,
    sideCheck: M[i,j] = -M[j,i],    
    b: diagCheck and sideCheck,
 /*Se la condizione è violata esco, altrimenti rilancio con la sottomatrice ottenuta cancellando la prima riga e la prima colonna*/
    if b = false then return(b) else return(isAsim(submatrix(i,M,j)))    
  )
)
)$
/*Data Matrice antisimmetrica determinare asse ed angolo*/
